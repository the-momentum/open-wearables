# Open Wearables - Mobile SDK Architecture Plan

## Context

Open Wearables needs to expand from its current Apple Health-only SDK to support **3 providers** (Apple Health, Google Health Connect, Samsung Health) across **2 cross-platform frameworks** (Flutter, React Native). The existing system works well: a Swift iOS SDK collects HealthKit data, sends it with native type identifiers (`HKQuantityTypeIdentifierHeartRate`), and the Python backend maps these to unified `SeriesType` values. The goal is to design an architecture that scales to multiple providers and frameworks while maintaining the quality and robustness of the current implementation.

---

## 1. Architectural Decisions

### 1.1 Type Mapping: Keep Server-Side (Current Approach)

**Recommendation**: SDK sends provider-native identifiers as strings. Backend maps to unified `SeriesType`.

**Why this is the right choice for Open Wearables**:
- **Already working**: `METRIC_TYPE_TO_SERIES_TYPE` in `backend/app/constants/series_types/apple.py` maps 35+ Apple metric types. Adding Google/Samsung is just new mapping dicts.
- **Deploy once**: Fix a mapping bug or add a new metric type by deploying the backend. No SDK release needed, no waiting for app store review.
- **Debuggability**: Logs show exactly what the device sent (`HKQuantityTypeIdentifierHeartRate`) AND what it mapped to (`SeriesType.heart_rate`). Client-side mapping loses the original identifier.
- **Unit conversion stays client-side**: The iOS SDK already converts HealthKit values to standard units (bpm, meters, kg) via `_defaultUnit()` in `Types.swift:425`. This is correct -- the SDK knows the native unit system, the backend doesn't need to.
- **Types are always strings**: Each SDK converts its native type objects to string identifiers before upload. Sometimes this requires SDK-side pre-mapping (e.g., Google Health Connect's `HeartRateRecord` class → `"HeartRateRecord"` string). The backend receives these strings and maps them to `SeriesType` per provider.

**What to add**: A lightweight allowlist on the SDK that skips unsupported types before uploading (reduces bandwidth, not a full mapping).

**Trade-off**: Backend grows one mapping module per provider (~150 lines each). At 3 providers this is trivially manageable.

### 1.2 Payload Format: Unified Schema for All Providers

**Recommendation**: All providers send data in the same unified schema. The backend routes by provider (from URL path) and applies provider-specific type mappings.

**Current state**: The sync endpoint already routes by provider (`/sdk/users/{user_id}/sync/{provider}`). The existing Apple schema serves as the foundation for the unified format.

**Key design principles**:
- **One schema, all providers**: Same JSON structure regardless of whether data comes from Apple Health, Google Health Connect, or Samsung Health. Field names and nesting are identical.
- **Types remain provider-specific strings**: The `type` field carries the provider's native identifier (`"HKQuantityTypeIdentifierHeartRate"` for Apple, `"HeartRateRecord"` for Google HC). Backend interprets per provider.
- **Sleep supports optional `parentId`**: Providers with native sleep sessions (Google HC, Samsung) send a parent session record + child stage records linked via `parentId`. Providers without sessions (Apple) send flat phase records without `parentId` -- backend reconstructs sessions via existing Redis state machine.

**Backend structure**:
```
backend/app/
  schemas/
    sdk/
      sync_request.py               # UNIFIED schema for all providers
  constants/series_types/
    apple.py                         # existing - HK identifier → SeriesType
    google.py                        # new - HC record type → SeriesType
    samsung.py                       # new (if separate from Google)
  constants/workout_types/
    apple_sdk.py                     # existing
    google.py                        # new
  services/
    sdk/
      import_service.py              # unified, receives provider as param
      sleep_service.py               # updated: handles parentId + Redis paths
  integrations/celery/tasks/
    process_apple_upload_task.py      # existing
    process_google_upload_task.py     # new
    process_samsung_upload_task.py    # existing, extend
```

**Why unified over provider-specific schemas**: A single schema means one validation path, one set of field names, and one documentation source. Provider-specific interpretation happens only in the mapping layer (constants), not in schema or serialization. Debugging remains easy -- the `type` strings tell you exactly what the device sent.

### 1.3 Proposed Unified Payload Format

#### Top-level structure

```json
{
  "data": {
    "records": [ ... ],
    "sleep": [ ... ],
    "workouts": [ ... ]
  }
}
```

All three arrays are optional -- a sync batch can contain any combination.

---

#### records (time-series measurements)

```json
{
  "id": "0F12CD84-80C1-45D2-A0CD-474C144602C4",
  "type": "HKQuantityTypeIdentifierHeartRate",
  "value": 72,
  "unit": "bpm",
  "startDate": "2024-01-01T03:54:07Z",
  "endDate": "2024-01-01T03:57:20Z",
  "source": {
    "name": "Apple Watch",
    "deviceManufacturer": "Apple",
    "deviceModel": "Watch",
    "deviceHardwareVersion": "Watch5,2",
    "deviceSoftwareVersion": "10.7.0",
    "appId": "com.apple.health"
  },
  "metadata": [{"key": "HKWasUserEntered", "value": "0"}]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | yes | Stable unique ID from provider (HealthKit UUID, HC `Record.metadata.id`) |
| `type` | string | yes | Provider-specific type identifier |
| `value` | number | yes | Measurement value in standardized units |
| `unit` | string | yes | Standardized unit (bpm, m, kg, Cal, etc.) |
| `startDate` | ISO 8601 | yes | Sample start time |
| `endDate` | ISO 8601 | yes | Sample end time |
| `source` | object | no | Device/app info (all fields optional) |
| `metadata` | list | no | Provider-specific key-value pairs |

**`type` examples per provider**:
- **Apple**: `"HKQuantityTypeIdentifierHeartRate"`, `"HKQuantityTypeIdentifierStepCount"`, `"HKQuantityTypeIdentifierBodyMass"`
- **Google HC**: `"HeartRateRecord"`, `"StepsRecord"`, `"WeightRecord"`
- **Samsung**: Same as Google HC if via Health Connect, or Samsung-specific strings if via Samsung Health SDK

---

#### sleep (sessions and phases)

Flat records with optional `parentId`. Sessions and phases coexist at the same level in the array.

**Why payloads differ per provider -- and why `parentId` is optional:**

The difference stems from how each platform's health API models sleep:

- **Apple HealthKit** has no concept of a "sleep session". It stores sleep as individual `HKCategorySample` records, each representing a single phase transition (e.g., "deep sleep from 22:00 to 22:45"). All records share the same type (`HKCategoryTypeIdentifierSleepAnalysis`) and differ only by `value` (0=IN_BED, 1=ASLEEP_UNSPECIFIED, 2=AWAKE, 3=LIGHT, 4=DEEP, 5=REM). There is no parent record linking them -- HealthKit simply returns a flat list of time-stamped phase samples. Our backend already reconstructs sessions from these flat phases using a Redis-based state machine (`sleep_service.py`) that groups consecutive phases and detects session boundaries via gap analysis (>1 hour gap = session end).

- **Google Health Connect** natively models sleep as a `SleepSessionRecord` that contains a list of `Stage` objects. The session is the parent, stages are children. This is a first-class relationship in the Health Connect API.

- **Samsung Health SDK** follows a similar pattern to Google HC -- sessions with nested stage data.

Because Apple's API fundamentally cannot provide a parent session ID, `parentId` must be optional. Providers that have native sessions (Google HC, Samsung) send both the session record and its child stages linked via `parentId`. Apple sends only flat phase records without `parentId`, and the backend continues to reconstruct sessions from them as it does today.

**Google Health Connect example (structured with parentId):**

```json
[
  {
    "id": "session-abc-123",
    "type": "SleepSessionRecord",
    "startDate": "2024-01-01T22:00:00Z",
    "endDate": "2024-01-02T06:30:00Z",
    "source": { "name": "Pixel Watch", "deviceManufacturer": "Google" }
  },
  {
    "id": "stage-001",
    "type": "STAGE_TYPE_DEEP",
    "startDate": "2024-01-01T22:00:00Z",
    "endDate": "2024-01-01T22:45:00Z",
    "parentId": "session-abc-123"
  },
  {
    "id": "stage-002",
    "type": "STAGE_TYPE_REM",
    "startDate": "2024-01-01T22:45:00Z",
    "endDate": "2024-01-01T23:30:00Z",
    "parentId": "session-abc-123"
  },
  {
    "id": "stage-003",
    "type": "STAGE_TYPE_LIGHT",
    "startDate": "2024-01-01T23:30:00Z",
    "endDate": "2024-01-02T01:00:00Z",
    "parentId": "session-abc-123"
  }
]
```

**Apple HealthKit example (flat phases, no parentId):**

```json
[
  {
    "id": "apple-uuid-001",
    "type": "HKCategoryTypeIdentifierSleepAnalysis",
    "value": 4,
    "startDate": "2024-01-01T22:00:00Z",
    "endDate": "2024-01-01T22:45:00Z",
    "source": { "name": "Apple Watch" }
  },
  {
    "id": "apple-uuid-002",
    "type": "HKCategoryTypeIdentifierSleepAnalysis",
    "value": 5,
    "startDate": "2024-01-01T22:45:00Z",
    "endDate": "2024-01-01T23:30:00Z",
    "source": { "name": "Apple Watch" }
  }
]
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | yes | Stable unique ID from provider |
| `type` | string | yes | Provider-specific (session type or stage type) |
| `startDate` | ISO 8601 | yes | Start time |
| `endDate` | ISO 8601 | yes | End time |
| `value` | number | no | Phase value (Apple: 0=IN_BED, 1=ASLEEP_UNSPECIFIED, 2=AWAKE, 3=LIGHT, 4=DEEP, 5=REM) |
| `parentId` | string | no | Links stage to parent sleep session |
| `source` | object | no | Device/app info |

**Backend processing (two paths):**

1. Build `parentId → children` map from all sleep records in batch
2. Records **with parentId** → sleep stages, aggregated into parent session
3. Records **without parentId but referenced as parent** → sleep sessions → create `EventRecord + SleepDetails` directly from aggregated child stages
4. Records **without parentId and not a parent** (orphans) → existing Redis state machine path (current Apple logic)

---

#### workouts (exercise sessions)

```json
{
  "id": "workout-uuid-789",
  "type": "running",
  "startDate": "2024-01-01T06:00:00Z",
  "endDate": "2024-01-01T07:00:00Z",
  "source": { "name": "Apple Watch" },
  "statistics": [
    { "type": "distance", "unit": "m", "value": 5000 },
    { "type": "activeEnergyBurned", "unit": "Cal", "value": 450 },
    { "type": "averageHeartRate", "unit": "bpm", "value": 150 }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | yes | Stable unique ID |
| `type` | string | yes | Provider-specific workout type |
| `startDate` | ISO 8601 | yes | Workout start |
| `endDate` | ISO 8601 | yes | Workout end |
| `source` | object | no | Device/app info |
| `statistics` | list | no | Workout metrics (distance, energy, heart rate, etc.) |

---

#### source (device info, shared across all record types)

```json
{
  "name": "Apple Watch",
  "deviceManufacturer": "Apple",
  "deviceModel": "Watch",
  "deviceHardwareVersion": "Watch5,2",
  "deviceSoftwareVersion": "10.7.0",
  "appId": "com.apple.health"
}
```

All fields optional. Each provider fills what it can.

### 1.4 Core Logic: Heavy Native, Thin Bridge

**Recommendation**: All health data collection, background sync, serialization, upload, and outbox logic lives in standalone native SDKs. Flutter/RN are thin bridges (~200 lines each).

**Architecture**:
```
[iOS Swift Package]                    [Android Kotlin Library]
OpenWearablesHealthSDK                 OpenWearablesHealthSDK
(HealthKit, background delivery,       (Health Connect, WorkManager,
 anchor sync, outbox, keychain)         change tokens, Room outbox, Keystore)
       |                    |                  |                    |
[Flutter iOS Plugin]  [RN iOS Module]  [Flutter Android Plugin]  [RN Android Module]
(~200 lines Swift)    (~200 lines Swift) (~200 lines Kotlin)    (~200 lines Kotlin)
       |                    |                  |                    |
[Flutter Dart API]    [RN TypeScript API]  [Flutter Dart API]   [RN TypeScript API]
```

**This is already the pattern**: The existing iOS Swift SDK (`open_wearables_ios_sdk/`) is a standalone Swift Package. The Flutter plugin (`OpenWearablesHealthSdkPlugin.swift`, 207 lines) just delegates to `OpenWearablesHealthSDK.shared`. The same Swift Package can be consumed by a React Native native module.

**Biggest gap**: No Android native SDK exists yet. This is the largest piece of new work.

---

## 2. Flutter SDK Organization: Federated Plugin

**Recommendation**: Split into federated packages.

```
open_wearables_health_sdk/
  open_wearables_health_sdk/                    # App-facing package
    lib/
      open_wearables_health_sdk.dart            # Public API singleton
      src/
        health_data_type.dart
        config.dart
        user.dart
        sync_status.dart
  open_wearables_health_sdk_platform_interface/  # Shared contract
    lib/
      open_wearables_health_sdk_platform_interface.dart
      src/
        method_channel_impl.dart
        types.dart
  open_wearables_health_sdk_ios/                 # iOS implementation
    ios/Classes/
      OpenWearablesHealthSdkPlugin.swift         # existing, thin bridge
    lib/
      open_wearables_health_sdk_ios.dart
  open_wearables_health_sdk_android/             # Android implementation (NEW)
    android/src/main/kotlin/
      OpenWearablesHealthSdkPlugin.kt            # thin bridge to Kotlin SDK
    lib/
      open_wearables_health_sdk_android.dart
```

**Migration**: The current code already follows PlatformInterface pattern. The main work is splitting into packages and adding the Android implementation.

### React Native SDK

```
open-wearables-health-rn/
  src/
    index.ts                           # Public API
    types.ts                           # TypeScript types (mirror Dart enums)
    NativeOpenWearablesHealth.ts        # TurboModule spec
  ios/
    OpenWearablesHealthModule.swift     # Bridges to same iOS Swift Package
  android/src/main/kotlin/
    OpenWearablesHealthModule.kt        # Bridges to same Android Kotlin SDK
```

Uses React Native New Architecture (TurboModules) for type-safe bridging.

---

## 3. Android Native SDK Design

The Android Kotlin SDK mirrors the iOS Swift SDK structure:

```
open_wearables_android_sdk/
  src/main/kotlin/com/openwearables/sdk/
    OpenWearablesHealthSDK.kt          # Main singleton (mirrors iOS)
    internal/
      HealthConnectProvider.kt         # Health Connect data collection
      Anchors.kt                       # Change token management (like iOS HKQueryAnchor)
      Background.kt                    # WorkManager periodic sync
      Outbox.kt                        # Room-based failed upload queue
      Session.kt                       # Resumable sync sessions
      SecureStorage.kt                 # Android Keystore + EncryptedSharedPreferences
      Types.kt                         # HealthDataType enum + HC type mapping
      Serialization.kt                 # HC records -> JSON payload
```

**Key differences from iOS**:
- **Background sync**: `WorkManager` with `PeriodicWorkRequest` (min 15-min interval) instead of `HKObserverQuery` + `BGTaskScheduler`
- **Incremental sync**: Health Connect `getChangesToken()` / `getChanges()` instead of `HKAnchoredObjectQuery`
- **Outbox**: Room database instead of file-based
- **Secure storage**: Android Keystore + `EncryptedSharedPreferences` instead of iOS Keychain
- **Permissions**: Health Connect returns explicit `GRANTED`/`DENIED` (unlike HealthKit's privacy-by-design where you can't know)

---

## 4. Additional Considerations

### 4.1 Payload Compression
Large initial exports can be megabytes. Add gzip:
- iOS: `Data.compressed(using: .zlib)`, set `Content-Encoding: gzip`
- Android: `GZIPOutputStream`
- FastAPI handles decompression automatically

### 4.2 SDK Version Header
Send `X-SDK-Version: flutter-ios/1.2.0` (or `rn-android/1.0.0`) with every API request. Backend logs and stores it per batch. Enables:
- Diagnosing version-specific bugs
- Deprecating old SDK versions (return `426 Upgrade Required`)

### 4.3 Remote Configuration Endpoint
```
GET /api/v1/sdk/config
{
  "min_sdk_version": "1.1.0",
  "sync_chunk_size": 2000,
  "telemetry_enabled": true,
  "supported_providers": ["apple", "google_health_connect"]
}
```
Allows tuning SDK behavior without releases (chunk sizes, feature flags, deprecations).

### 4.4 Sleep Data Normalization

Sleep formats differ across providers:
- **Apple**: Individual `HKCategoryTypeIdentifierSleepAnalysis` records with phase values 0-5. No native session concept.
- **Google Health Connect**: `SleepSessionRecord` with `SleepSessionRecord.Stage` objects. Native parent-child structure.
- **Samsung**: Session with detailed stages (similar to Google HC).

**Unified approach (flat + parentId)**:

All providers use the same sleep array in the unified payload. Providers with native sessions (Google HC, Samsung) send a parent session record + child stage records linked via `parentId`. Apple sends flat phase records without `parentId`.

**Backend handles both paths**:
1. **Structured path** (records have `parentId`): Build parent→children map. Create `EventRecord + SleepDetails` directly by aggregating child stage durations. No Redis needed.
2. **Flat path** (no `parentId`, orphan records): Existing Redis-based sleep state machine reconstructs sessions from individual phases. Detects session boundaries via gap analysis (>1 hour gap = new session).

Both paths produce identical `EventRecord + SleepDetails` output. See Section 1.3 for payload examples.

### 4.5 Health Connect Permissions Model
Apple HealthKit returns `true` for `requestAuthorization()` even if the user denied (privacy by design). Health Connect returns explicit `GRANTED`/`DENIED`. The platform interface should account for this:
```dart
enum AuthorizationResult {
  granted,
  denied,
  undetermined,  // iOS -- cannot determine if granted
}
```

### 4.6 Deduplication
Already handled via `external_id` (UUID from HealthKit) with `ON CONFLICT DO NOTHING` on the backend. Ensure every provider sends stable unique IDs per record (Health Connect provides `Record.metadata.id`).

### 4.7 Rate Limiting & Exponential Backoff
SDK should implement backoff for failed uploads: 5s -> 30s -> 5min -> rely on periodic background sync. Backend should return `429` with `Retry-After` header if syncing too aggressively.

---

## 5. Critical Files Reference

**Existing (to extend)**:
- `open_wearables_ios_sdk/Sources/OpenWearablesHealthSDK/OpenWearablesHealthSDK.swift` -- iOS SDK singleton, pattern to mirror for Android
- `open_wearables_ios_sdk/Sources/OpenWearablesHealthSDK/Internal/Types.swift` -- HealthDataType enum + serialization, pattern for Android types
- `backend/app/constants/series_types/apple.py` -- Type mapping pattern to replicate for Google/Samsung
- `backend/app/constants/workout_types/apple_sdk.py` -- Workout mapping pattern
- `backend/app/schemas/apple/healthkit/sync_request.py` -- Current schema, basis for unified schema
- `backend/app/services/apple/healthkit/import_service.py` -- Import service pattern
- `backend/app/services/apple/healthkit/sleep_service.py` -- Redis-based sleep state machine (remains for Apple flat phases)
- `backend/app/api/routes/v1/sdk_sync.py` -- Sync endpoint (extend provider list)
- `open_wearables_health_sdk/lib/open_wearables_health_sdk_platform_interface.dart` -- Platform interface (extend for Android)
- `open_wearables_health_sdk/ios/Classes/OpenWearablesHealthSdkPlugin.swift` -- Flutter bridge pattern

**New (to create)**:
- Android Kotlin SDK (standalone library) with `HealthConnectProvider` + `SamsungHealthProvider`
- `backend/app/schemas/sdk/sync_request.py` -- Unified sync schema for all providers
- `backend/app/constants/series_types/google.py` -- Health Connect type mapping
- `backend/app/constants/series_types/samsung.py` -- Samsung Health type mapping (if separate from Google)
- `backend/app/constants/workout_types/google.py` -- Health Connect workout mapping
- `backend/app/services/sdk/import_service.py` -- Unified import service with provider param
- `backend/app/integrations/celery/tasks/process_google_upload_task.py`
- `backend/app/integrations/celery/tasks/process_samsung_upload_task.py` (already exists, extend)
- `open_wearables_health_sdk_android/` (Flutter federated package)
- `open-wearables-health-rn/` (React Native package with TurboModules)
- `backend/app/api/routes/v1/sdk_telemetry.py` (error telemetry endpoint)
